const std = @import("std");
const RocStr = @import("src/str.zig").RocStr;
const builtin = @import("builtin");

comptime {
    if (builtin.target.cpu.arch != .wasm32) {
        @compileError("This platform is for WebAssembly only. You need to pass `--target wasm32` to the Roc compiler.");
    }
    if (builtin.os.tag == .macos or builtin.os.tag == .linux) {
        @export(roc_getppid, .{ .name = "roc_getppid", .linkage = .Strong });
        @export(roc_mmap, .{ .name = "roc_mmap", .linkage = .Strong });
        @export(roc_shm_open, .{ .name = "roc_shm_open", .linkage = .Strong });
    }
}

const Align = extern struct { a: usize, b: usize };
extern fn malloc(size: usize) callconv(.C) ?*align(@alignOf(Align)) anyopaque;
extern fn realloc(c_ptr: [*]align(@alignOf(Align)) u8, size: usize) callconv(.C) ?*anyopaque;
extern fn free(c_ptr: [*]align(@alignOf(Align)) u8) callconv(.C) void;
extern fn memcpy(dest: *anyopaque, src: *anyopaque, count: usize) *anyopaque;

export fn roc_alloc(size: usize, alignment: u32) callconv(.C) ?*anyopaque {
    _ = alignment;

    return malloc(size);
}

export fn roc_realloc(c_ptr: *anyopaque, new_size: usize, old_size: usize, alignment: u32) callconv(.C) ?*anyopaque {
    _ = old_size;
    _ = alignment;

    return realloc(@alignCast(@alignOf(Align), @ptrCast([*]u8, c_ptr)), new_size);
}

export fn roc_dealloc(c_ptr: *anyopaque, alignment: u32) callconv(.C) void {
    _ = alignment;

    free(@alignCast(@alignOf(Align), @ptrCast([*]u8, c_ptr)));
}

export fn roc_memcpy(dest: *anyopaque, src: *anyopaque, count: usize) callconv(.C) void {
    _ = memcpy(dest, src, count);
}

export fn roc_panic(c_ptr: *anyopaque, tag_id: u32) callconv(.C) void {
    _ = tag_id;

    const stderr = std.io.getStdErr().writer();
    const msg = @ptrCast([*:0]const u8, c_ptr);
    stderr.print("Application crashed with message\n\n    {s}\n\nShutting down\n", .{msg}) catch unreachable;
    std.process.exit(0);
}

extern fn roc__mainForHost_1_exposed_generic(*RocStr) void;

pub fn main() u8 {

    var str = RocStr.empty();
    roc__mainForHost_1_exposed_generic(&str);

    // stdout the result
    const stdout = std.io.getStdOut().writer(); 
    stdout.print("{s}", .{str.asSlice()}) catch unreachable;

    return 0;
}

// WORK IN PROGRESS 
// ATTEMPTS TO GET `main : Str -> Str` for main working....

// pub extern fn roc__mainForHost_1_exposed_generic(_: *RocStr, _: *RocStr) void;

// pub fn main() u8 {
    
//     // Call Roc and get the Str
//     var arg = RocStr.empty();
//     var ret = RocStr.empty();

//     roc__mainForHost_1_exposed_generic(&ret, &arg);

//     // Print to stdio
//     const stdout = std.io.getStdOut().writer(); 
//     stdout.print("Printing...", .{}) catch unreachable;
//     stdout.print("{s}", .{ret.asSlice()}) catch unreachable;

//     // value.decref();

//     return 0;
// }
